<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Filip & Simon</title>
  <!-- Three background -->
  <script src="https://ajax.googleapis.com/ajax/libs/threejs/r76/three.min.js"></script>
  <link href="style.css" rel="stylesheet">

  <!-- Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/material-design-iconic-font/2.2.0/css/material-design-iconic-font.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="shortcut icon" href="logo3.ico" type="image/x-icon">

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Bungee+Shade" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Bungee Inline">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Fugaz One">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Open Sans">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Ubuntu">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Quicksand">

  <!-- Carousel -->
  <link rel='stylesheet' href='./carousel.min.css'/>

  <!-- Scaling -->  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

</head>

<body>
  <div id="container"></div>
  <div id="root"></div>


  <script type="x-shader/x-fragment" id="fragmentShader">  

		uniform vec2 resolution;
		uniform vec2 mouse;
		uniform vec2 mouseDelayed;
		uniform float mouseHold;
		uniform float time;

		void main() {

			vec2 position = ( gl_FragCoord.xy / resolution.xy );
			float color = 0.3;
			vec2 point2 = vec2(0.3 + 0.1*mouseDelayed.x, 1.4);
			vec2 mp_vec = position - point2;
			vec2 middle = mp_vec;
			mp_vec.y *= 2.0;
			float mp = length(mp_vec)*6.0;
			float middle_length = length(middle)*6.0;
			color /= sin(12.8*( 1.5 + (0.3*sin(0.1*time)))*mp/abs(middle_length+0.1) - 0.1*time);
      color = max(min(color, 1.0), 0.0);
      color = color*0.05 + 0.6 + 0.01 * mouseHold;

      gl_FragColor = vec4(vec3(color) + vec3(0.3), 1.0 );
      
		}
  </script>

  <script type="x-shader/x-fragment" id="fragmentShader3">  
		uniform vec2 mouseDelayed;
    uniform vec2 resolution;
    uniform float time;
    //uniform vec3 camPos;
    
    vec3 camPos = vec3(10.0 - 0.30 * mouseDelayed.x, 4.0 + 0.5 * mouseDelayed.y, 7.0 + 1.5 * mouseDelayed.x);
    

    const float EPSILON = 0.1;
    
    float intersectSDF(float distA, float distB) {
        return max(distA, distB);
    }
    
    float unionSDF(float distA, float distB) {
        return min(distA, distB);
    }
    
    float differenceSDF(float distA, float distB) {
        return max(distA, -distB);
    }
    
    float rand(vec2 co){
        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }
    
    float sphereSDF(vec3 p) {
      return length(p) - 1.0;
    }
    
    float cubeSDF( vec3 p, vec3 b, float r )
    {
      return length(max(abs(p)-b,0.0))-r;
    }
    
    float waterSDF(vec3 p) {
      float surface = 0.01*(sin(20.0*p.x + 50.0*time) + sin(20.0*p.z + 30.0*time) + 10.0 * sin(p.x * p.z + 4.0*time));
      return p.y - surface;
    }
    
    float sceneSDF(vec3 p) {
      return waterSDF(p);
    }
    
    vec3 estimateNormal(vec3 p) {
      return normalize(vec3(
          sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
          sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
          sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
      ));
  }
  
   
    
    void main()
    {
    
      vec3 normal = vec3(0.0);
      vec3 light = normalize(vec3 (1.0, 1.0, 1.0));
    
    
      vec3 camDirection = normalize(-camPos); // Point camera towards origo
    
      // Calculate camera orientation
      vec3 up = vec3(0.0,1.0,0.0);
      vec3 right = normalize(cross(camDirection, up));
      up = normalize(cross(right, camDirection));

      float x = 2.0 * gl_FragCoord.x/resolution.x - 1.0;
      float y = 2.0 * gl_FragCoord.y/resolution.y - 1.0;
    
      float screenRatio = resolution.x / resolution.y; 
      
      float nearClip = 2.0;
    
      // Pixel position
      float randomStart = 0.01 * rand(vec2(x, y));
      randomStart = 0.9;
      vec3 pixelPos = camPos + camDirection * ( nearClip + randomStart) + x * screenRatio * right + y * up;
    
      // Ray starting position
      vec3 ray = pixelPos;
      vec3 rayDirection = normalize(pixelPos - camPos);

      const float MAX_MARCHING_STEPS = 10.0;
    
      float v = 0.0; 
      for(float i = 0.0; i < MAX_MARCHING_STEPS; i++){
    
        float dist = sceneSDF(ray);
    
        if(dist < EPSILON){ // Hit surface
          normal = estimateNormal(ray);
    
          float diffuse = max(dot(normal, light), 0.0);
          float ambient = 0.00;
          vec3 R = reflect(-light, normal);
          vec3 V = normalize(camPos - ray); // View direction
          float specular = pow(max(dot(R, V), 0.0), 5.0);
          float specular2 = pow(max(dot(R, V), 0.0), 100.0);
          v +=  ambient +  0.44 * diffuse + 0.2 * specular;
        }
        ray += dist * rayDirection;
        
      }
      
      gl_FragColor = vec4(vec3(0.8) - 0.08 * vec3(1.3 * v, 1.3 * v, v), 1.0);
    }
  </script>

  <script type="x-shader/x-fragment" id="fragmentShader2">  
    uniform vec2 resolution;
    uniform vec2 mouse;
    uniform vec2 mouseDelayed;
    uniform float time;
    varying vec3 newPos;
    
    float displacementMod = (10.0 + 0.01*sin(0.1*time)) * 0.01 + mouseDelayed.x * 0.0001;
    // Cellular noise ("Worley noise") in 2D in GLSL.
    // Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
    // This code is released under the conditions of the MIT license.
    // See LICENSE file for details.
    // https://github.com/stegu/webgl-noise
    
    // Modulo 289 without a division (only multiplications)
    vec3 mod289(vec3 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }
    
    vec2 mod289(vec2 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }
    
    // Modulo 7 without a division
    vec3 mod7(vec3 x) {
      return x - floor(x * (1.0 / 7.0)) * displacementMod;
    }
    
    // Permutation polynomial: (34x^2 + x) mod 289
    vec3 permute(vec3 x) {
      return mod289((34.0 * x + 1.0) * x) * displacementMod;
    }
    
    // Cellular noise, returning F1 and F2 in a vec2.
    // Standard 3x3 search window for good F1 and F2 values
    vec2 cellular(vec2 P) {
    #define K 0.142857142857 // 1/7
    #define Ko 0.428571428571 // 3/7
    #define jitter 1.0 // Less gives more regular pattern
      vec2 Pi = mod289(floor(P));
      vec2 Pf = fract(P);
      vec3 oi = vec3(-1.0, 0.0, 1.0);
      vec3 of = vec3(-0.5, 0.5, 1.5);
      vec3 px = permute(Pi.x + oi);
      vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13
      vec3 ox = fract(p*K) - Ko;
      vec3 oy = mod7(floor(p*K))*K - Ko;
      vec3 dx = Pf.x + 0.5 + jitter*ox;
      vec3 dy = Pf.y - of + jitter*oy;
      vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared
      p = permute(px.y + Pi.y + oi); // p21, p22, p23
      ox = fract(p*K) - Ko;
      oy = mod7(floor(p*K))*K - Ko;
      dx = Pf.x - 0.5 + jitter*ox;
      dy = Pf.y - of + jitter*oy;
      vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared
      p = permute(px.z + Pi.y + oi); // p31, p32, p33
      ox = fract(p*K) - Ko;
      oy = mod7(floor(p*K))*K - Ko;
      dx = Pf.x - 1.5 + jitter*ox;
      dy = Pf.y - of + jitter*oy;
      vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared
      // Sort out the two smallest distances (F1, F2)
      vec3 d1a = min(d1, d2);
      d2 = max(d1, d2); // Swap to keep candidates for F2
      d2 = min(d2, d3); // neither F1 nor F2 are now in d3
      d1 = min(d1a, d2); // F1 is now in d1
      d2 = max(d1a, d2); // Swap to keep candidates for F2
      d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller
      d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x
      d1.yz = min(d1.yz , d2.yz); // F2 is now not in d2.yz
      return d1.xy;
    }

    void main() {
      vec2 position = ( gl_FragCoord.xy / resolution.xx );

      float contrast = 0.2;
      float noise = cellular( 18.0*vec2(position.x, position.y)).x;
      noise = contrast * noise  + (1.0 - contrast) * 0.5;
      noise = noise * noise;
      float noiseInv = 1.0-noise;

      noise += (0.05*abs(sin(gl_FragCoord.y)));
      noise += (0.1*abs(sin(gl_FragCoord.x)));
      gl_FragColor = vec4(vec3(2.0*noise + 0.0) + 0.2*vec3(0.2, 0.6, 0.9), 1.0 );
    }
   
  </script>

</body>

</html>