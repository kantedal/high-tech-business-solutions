<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Filip & Simon</title>
  <!-- Dynamic background -->
  <script src="http://threejs.org/build/three.min.js"></script>
  <link href="style.css" rel="stylesheet">

  <!-- Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/material-design-iconic-font/2.2.0/css/material-design-iconic-font.min.css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="shortcut icon" href="logo3.ico" type="image/x-icon">

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Bungee+Shade" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Bungee Inline">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Fugaz One">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

</head>

<body>
  <div id="container"></div>
  <div id="root"></div>


  <script type="x-shader/x-fragment" id="fragmentShader">  

		uniform vec2 resolution;
		uniform vec2 mouse;
		uniform vec2 mouseDelayed;
		uniform float mouseHold;
		uniform float time;

		void main() {

			vec2 position = ( gl_FragCoord.xy / resolution.xy );
			float color = 0.3;
			vec2 point2 = vec2(0.3 + 0.1*mouseDelayed.x, 1.4);
			vec2 mp_vec = position - point2;
			vec2 middle = mp_vec;
			mp_vec.y *= 2.0;
			float mp = length(mp_vec)*6.0;
			float middle_length = length(middle)*6.0;
			color /= sin(12.8*( 1.5 + (0.3*sin(0.1*time)))*mp/abs(middle_length+0.1) - 0.1*time);
      color = max(min(color, 1.0), 0.0);
      color = color*0.05 + 0.6 + 0.01 * mouseHold;

      gl_FragColor = vec4(vec3(color) + vec3(0.2, 0.2, 0.2), 1.0 );
      
		}
  </script>

  <script type="x-shader/x-fragment" id="fragmentShader2">  
    uniform vec2 resolution;
    uniform vec2 mouse;
    uniform vec2 mouseDelayed;
    uniform float time;
    varying vec3 newPos;
    
    float displacementMod = (10.0 + 0.01*sin(0.1*time)) * 0.01 + mouseDelayed.x * 0.0001;
    // Cellular noise ("Worley noise") in 2D in GLSL.
    // Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.
    // This code is released under the conditions of the MIT license.
    // See LICENSE file for details.
    // https://github.com/stegu/webgl-noise
    
    // Modulo 289 without a division (only multiplications)
    vec3 mod289(vec3 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }
    
    vec2 mod289(vec2 x) {
      return x - floor(x * (1.0 / 289.0)) * 289.0;
    }
    
    // Modulo 7 without a division
    vec3 mod7(vec3 x) {
      return x - floor(x * (1.0 / 7.0)) * displacementMod;
    }
    
    // Permutation polynomial: (34x^2 + x) mod 289
    vec3 permute(vec3 x) {
      return mod289((34.0 * x + 1.0) * x) * displacementMod;
    }
    
    // Cellular noise, returning F1 and F2 in a vec2.
    // Standard 3x3 search window for good F1 and F2 values
    vec2 cellular(vec2 P) {
    #define K 0.142857142857 // 1/7
    #define Ko 0.428571428571 // 3/7
    #define jitter 1.0 // Less gives more regular pattern
      vec2 Pi = mod289(floor(P));
      vec2 Pf = fract(P);
      vec3 oi = vec3(-1.0, 0.0, 1.0);
      vec3 of = vec3(-0.5, 0.5, 1.5);
      vec3 px = permute(Pi.x + oi);
      vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13
      vec3 ox = fract(p*K) - Ko;
      vec3 oy = mod7(floor(p*K))*K - Ko;
      vec3 dx = Pf.x + 0.5 + jitter*ox;
      vec3 dy = Pf.y - of + jitter*oy;
      vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared
      p = permute(px.y + Pi.y + oi); // p21, p22, p23
      ox = fract(p*K) - Ko;
      oy = mod7(floor(p*K))*K - Ko;
      dx = Pf.x - 0.5 + jitter*ox;
      dy = Pf.y - of + jitter*oy;
      vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared
      p = permute(px.z + Pi.y + oi); // p31, p32, p33
      ox = fract(p*K) - Ko;
      oy = mod7(floor(p*K))*K - Ko;
      dx = Pf.x - 1.5 + jitter*ox;
      dy = Pf.y - of + jitter*oy;
      vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared
      // Sort out the two smallest distances (F1, F2)
      vec3 d1a = min(d1, d2);
      d2 = max(d1, d2); // Swap to keep candidates for F2
      d2 = min(d2, d3); // neither F1 nor F2 are now in d3
      d1 = min(d1a, d2); // F1 is now in d1
      d2 = max(d1a, d2); // Swap to keep candidates for F2
      d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller
      d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x
      d1.yz = min(d1.yz , d2.yz); // F2 is now not in d2.yz
      return d1.xy;
    }

    void main() {
      vec2 position = ( gl_FragCoord.xy / resolution.xx );

      float contrast = 0.2;
      float noise = cellular( 18.0*vec2(position.x, position.y)).x;
      noise = contrast * noise  + (1.0 - contrast) * 0.5;
      noise = noise * noise;
      float noiseInv = 1.0-noise;

      noise += (0.05*abs(sin(gl_FragCoord.y)));
      noise += (0.1*abs(sin(gl_FragCoord.x)));
      gl_FragColor = vec4(vec3(2.0*noise + 0.0) + 0.2*vec3(0.2, 0.6, 0.9), 1.0 );
    }
   
  </script>

</body>

</html>