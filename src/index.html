<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Filip & Simon</title>
  <link href="style.css" rel="stylesheet">

  <!-- Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/material-design-iconic-font/2.2.0/css/material-design-iconic-font.min.css">
  <link rel="shortcut icon" href="logo5.ico" type="image/x-icon">

  <!-- Fonts -->
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Fugaz One">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Quicksand">

  <!-- Carousel -->
  <link rel='stylesheet' href='./carousel.min.css'/>

  <!-- Scaling -->  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

</head>

<body>
  <div id="container"></div>
  <div id="root"></div>

  <script type="x-shader/x-fragment" id="fragmentShader">
    void main(void) {
      gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    } 
  </script>

  <script type="x-shader/x-fragment" id="fragmentShader3">  
    precision highp float;
		uniform vec2 mouseDelayed;
    uniform vec2 resolution;
    uniform float time;
    
    const float EPSILON = 0.1;
    
    float intersectSDF(float distA, float distB) {
      return max(distA, distB);
    }
    
    float unionSDF(float distA, float distB) {
      return min(distA, distB);
    }
    
    float differenceSDF(float distA, float distB) {
      return max(distA, -distB);
    }
    
    float rand(vec2 co){
      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
    }
    
    float sphereSDF(vec3 p) {
      return length(p) - 1.0;
    }
    
    float cubeSDF(vec3 p, vec3 b, float r) {
      return length(max(abs(p)-b,0.0)) - r;
    }
    
    float waterSDF(vec3 p) {
      float surface = 0.01*(sin(20.0*p.x + 50.0*time) + sin(20.0*p.z + 30.0*time) + 10.0 * sin(p.x * p.z + 4.0*time));
      return p.y - surface;
    }
    
    float sceneSDF(vec3 p) {
      return waterSDF(p);
    }
    
    vec3 estimateNormal(vec3 p) {
      return normalize(vec3(
          sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),
          sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),
          sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))
      ));
    }
  
    void main() {
      vec3 camPos = vec3(10.0 - 0.30 * mouseDelayed.x, 4.0 + 0.5 * mouseDelayed.y, 7.0 + 1.5 * mouseDelayed.x);
      vec3 normal = vec3(0.0);
      vec3 light = normalize(vec3 (1.0, 1.0, 1.0));
    
      vec3 camDirection = normalize(-camPos); // Point camera towards origo
    
      // Calculate camera orientation
      vec3 up = vec3(0.0, 1.0 ,0.0);
      vec3 right = normalize(cross(camDirection, up));
      up = normalize(cross(right, camDirection));

      float x = 2.0 * gl_FragCoord.x / resolution.x - 1.0;
      float y = 2.0 * gl_FragCoord.y / resolution.y - 1.0;
    
      float screenRatio = resolution.x / resolution.y; 
      
      float nearClip = 2.0;
    
      // Pixel position
      float randomStart = 0.01 * rand(vec2(x, y));
      randomStart = 0.9;
      vec3 pixelPos = camPos + camDirection * (nearClip + randomStart) + x * screenRatio * right + y * up;
    
      // Ray starting position
      vec3 ray = pixelPos;
      vec3 rayDirection = normalize(pixelPos - camPos);

      const float MAX_MARCHING_STEPS = 10.0;
    
      float v = 0.0; 
      for(float i = 0.0; i < MAX_MARCHING_STEPS; i++){
    
        float dist = sceneSDF(ray);
    
        if (dist < EPSILON){ // Hit surface
          normal = estimateNormal(ray);
    
          float diffuse = max(dot(normal, light), 0.0);
          float ambient = 0.00;
          vec3 R = reflect(-light, normal);
          vec3 V = normalize(camPos - ray); // View direction
          float specular = pow(max(dot(R, V), 0.0), 5.0);
          float specular2 = pow(max(dot(R, V), 0.0), 100.0);
          v +=  ambient +  0.44 * diffuse + 0.2 * specular;
        }
        ray += dist * rayDirection;
        
      }
      
      gl_FragColor = vec4(vec3(0.8) - 0.08 * vec3(1.3 * v, 1.3 * v, v), 1.0);
    }
  </script>

</body>

</html>